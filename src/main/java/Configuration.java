import java.io.Serializable;
import java.security.SecureRandom;
import java.util.Objects;
import java.util.concurrent.TimeUnit;

public class Configuration implements Serializable {
    // Total processes
    public final int n;
    // Total byzantine processes
    public final int t;
    // Max differences between processes
    public final double e;
    // Mean and standardDeviation of initial values (generated by normal distribution)
    public final double mean, standardDeviation;
    // Mutated Gossip Dispatcher config
    public final int fanout, delay;
    public final TimeUnit delayTimeUnit;
    // Random generator
    protected transient final SecureRandom random;
    // Client.Client debug mode - If true each client will create a file with logs
    public transient final boolean clientDebug;

    private Configuration(int n, int t, double e, double mean, double standardDeviation, int fanout, int delay, TimeUnit delayTimeUnit, boolean clientDebug) {
        this.n = n;
        this.t = t;
        this.e = e;
        this.mean = mean;
        this.standardDeviation = standardDeviation;
        this.fanout = fanout;
        this.delay = delay;
        this.delayTimeUnit = delayTimeUnit;
        this.clientDebug = clientDebug;
        this.random = new SecureRandom();
    }

    public double getRandomValue() {
        //used to generate byzantine values
        return Math.abs(random.nextInt((int) Math.floor(mean + standardDeviation)) + 1.);
    }

    public double getInitialValue() {
        //used to generate initial values
        return random.nextGaussian() * standardDeviation + mean;
    }

    public int nextInt(int bound) {
        return random.nextInt(bound);
    }

    public String toString() {
        return "n=" + n +
                ", t=" + t +
                ", e=" + e +
                ", st=" + standardDeviation +
                ", fanout = " + fanout +
                ", delay = " + delay;
    }

    public static class Builder {
        private int n, t, fanout, delay;
        private double e, mean, standardDeviation;
        private boolean clientDebug;
        private TimeUnit delayTimeUnit;

        public Builder setEpsilon(double e) {
            this.e = e;
            return this;
        }

        public Builder setMean(double mean) {
            this.mean = mean;
            return this;
        }

        public Builder setProcessesNumber(int n) {
            this.n = n;
            return this;
        }

        public Builder setStandardDeviation(double standardDeviation) {
            this.standardDeviation = standardDeviation;
            return this;
        }

        public Builder setFaultyProcessesNumber(int t) {
            this.t = t;
            return this;
        }

        public Builder setFanout(int fanout) {
            this.fanout = fanout;
            return this;
        }

        public Builder setDelay(int delay, TimeUnit timeUnit) {
            this.delay = delay;
            this.delayTimeUnit = timeUnit;
            return this;
        }

        public Builder setClientDebugMode(boolean clientDebug) {
            this.clientDebug = clientDebug;
            return this;
        }

        public Configuration build(){
            if( t <= 0) t = (n-1)/5;
            if( n < 5*t +1) throw new IllegalArgumentException("n must be equal to or greater than 5t+1");
            if( fanout > n || fanout < 0)
                throw new IllegalArgumentException("Fanout must be a non negative number less than n");
            if( delay < 0)
                throw new IllegalArgumentException("Delay must be a non negative number");
            return new Configuration(n,t,e,mean,standardDeviation,fanout, delay, delayTimeUnit, clientDebug);

        }
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Configuration that = (Configuration) o;
        return n == that.n &&
                t == that.t &&
                Double.compare(that.e, e) == 0 &&
                Double.compare(that.mean, mean) == 0 &&
                Double.compare(that.standardDeviation, standardDeviation) == 0 &&
                Double.compare(that.delay, delay) == 0 &&
                Double.compare(that.fanout, fanout) == 0;
    }

    @Override
    public int hashCode() {
        return Objects.hash(n, t, e, mean, standardDeviation);
    }
}
